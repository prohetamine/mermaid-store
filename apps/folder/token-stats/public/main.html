<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Mini Token Stats</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.5.4/socket.io.js" integrity="sha512-YeeA/Qxn5hYdkukScTCNNOhTrv1C2RubAGButJ1rmgQwZf/HdRaCGl+JAVkqsqaNRaYNHdheiuKKuPf9mDcqKg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src='app-transport-channel.js'></script>
  <link rel="stylesheet" href="main.css">
</head>
<body>
  <canvas width="158" height="88"></canvas>
  <script>
    const AppTransportChannel = MermaidAppTransportChannel()

    const canvas = document.querySelector('canvas')
        , ctx = canvas.getContext('2d')

    const timing = 5000

    const stat = {}

    const draw = data => {
      ctx.fillStyle = '#F8F8F8'
      ctx.fillRect(0, 0, 158, 88)

      for (let i = 0; i < 12; i++) {
        ctx.fillStyle = '#696969'
        ctx.fillRect(25 + (i * 11), 79, 1, 5)
      }

      for (let i = 0; i < 11; i++) {
        ctx.fillStyle = '#696969'
        ctx.fillRect(31 + (i * 11), 81, 1, 3)
      }

      const getMaxTips = (max => max > 15 ? max : 15)(Object.keys(data).slice(-720).map(site => data[site].data.sort((a, b) => b.tip - a.tip)[0].tip).sort((a, b) => b - a)[0])

      for (let i = 5; i > 0; i--) {
        ctx.fillStyle = '#696969';
        ctx.font = '4px';
        const step = i === 5 ? 0 : (s => s > 999 ? (s => parseInt(s) === parseFloat(s) ? parseInt(s) : s)((s / 1000).toFixed(1)) + 'k' : s.toFixed(0))(getMaxTips / i)
        if ((parseInt(step) !== 0 || i === 5)) {
          if (!(i === 2 && getMaxTips === 1)) {
            ctx.fillText(step, 4, 3 + (i * 14))
          }
        }
      }

      Object.keys(data).forEach(site => {
        let endPointX = 0
          , endPointY = 0

        ctx.strokeStyle = data[site].color
        ctx.beginPath()
        data[site].data.sort((a, b) => a.tip - b.tip).slice(-720).forEach(({ time, tip }, i, array) => {
          if (i === 0) {
            ctx.moveTo(24 + i * 0.85, 75 - (tip / getMaxTips) * 63)
          } else {
            const x = 24 + i * 0.17
                , y = 75 - (tip / getMaxTips) * 63

            ctx.lineTo(x, y)
            if (array.length - 1 === i) {
              endPointX = x
              endPointY = y
            }
          }
        })
        ctx.stroke()

        ctx.beginPath()
        ctx.arc(endPointX, endPointY, 2, 0, 2 * Math.PI, false)
        ctx.fillStyle = data[site].color
        ctx.fill()
      })
    }

    let chaturbateTip = 0
      , xhamsterliveTip = 0
      , modelUsernameChatrubate = null
      , modelUsernameXhamsterLive = null
      , windowIdXhamsterLive = null
      , windowIdChaturbate = null

    AppTransportChannel.on('connect', () => {
      AppTransportChannel.on('readData', async ({ type, data }) => {
        if (type === 'tip-message') {
          if (!stat[data.extension.platform] || (stat[data.extension.platform] && data.extension.modelUsername !== stat[data.extension.platform].modelUsername || data.extension.windowId !== stat[data.extension.platform].windowId)) {
            stat[data.extension.platform] = {
              color: data.extension.color,
              data: Array(720).fill(true).map((_, i) => ({
                tip: 0,
                date: new Date() - timing * 2
              })),
              modelUsername: data.extension.modelUsername,
              windowId: data.extension.windowId
            }
          }

          if (data.extension.platform === 'chaturbate') {
            stat[data.extension.platform].data[stat[data.extension.platform].data.length - 1].tip += parseInt(data.amount)
            draw(stat)
          }

          if (data.extension.platform === 'xhamsterlive') {
            stat[data.extension.platform].data[stat[data.extension.platform].data.length - 1].tip += parseInt(data.details.amount)
            draw(stat)
          }

          if (data.extension.platform === 'stripchat') {
            stat[data.extension.platform].data[stat[data.extension.platform].data.length - 1].tip += parseInt(data.details.amount)
            draw(stat)
          }
        }
      })
    })

    AppTransportChannel.on('readData', async ({ type }) => {
      if (type === 'reload') {
        window.location.reload()
      }
    })

    document.querySelector('canvas').addEventListener('dblclick', () => {
      AppTransportChannel.openWindow({
        file: 'mini.html',
        width: 158,
        height: 88,
        //titleBarStyle: 'hidden',
        frame: false,
        alwaysOnTop: true
      })
    })

    setInterval(() => {
      Object.keys(stat).forEach(site => {
        if (new Date() - 0 > stat[site].data[stat[site].data.length - 1].date + timing) {
          stat[site].data.push({
            tip: stat[site].data[stat[site].data.length - 1].tip,
            date: new Date() - 0
          })
        }
      })

      draw(stat)
    }, timing)

    draw(stat)
  </script>
</body>
</html>
